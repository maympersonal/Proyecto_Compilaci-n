42;
print(42);
function operate(x, y) {
    print(x + y);
    print(x - y);
    print(x * y);
    print(x / y);
}
function id(<args>) => {
   // <...>
}
let msg = "Hello World" in print(msg);
let number = 42, text = "The meaning of life is" in
    print(text @ number);
let number = 42 in
    let text = "The meaning of life is" in
        print(text @ number);
let number = 42 in (
    let text = "The meaning of life is" in (
            print(text @ number)
        )
    );
let a = 6, b = a * 7 in print(b);
let a = 6 in
    let b = a * 7 in
        print(b);
let a = 5, b = 10, c = 20 in {
    print(a+b);
    print(b*c);
    print(c/a);
}
let a = (let b = 6 in b * 7) in print(a);
print((((1 + 2) ^ 3) * 4) / 5);
print(let b = 6 in b * 7);
let a = 20 in {
    let a = 42 in print(a);
    print(a);
}
let a = 7, a = 7 * 6 in print(a);
let a = 7 in
    let a = 7 * 6 in
        print(a);
let a = 0 in {
    print(a);
    a := 1;
    print(a);
}
let a = 0 in
    let b = a := 1 in {
        print(a);
        print(b);
    };
let a = 42 in if (a % 2 == 0) print("Even") else print("odd");
let a = 42 in print(if (a % 2 == 0) "even" else "odd");
let a = 42 in
    if (a % 2 == 0) {
        print(a);
        print("Even");
    }
    else print("Odd");
let a = 42, let mod = a % 3 in
    print(
        if (mod == 0) "Magic"
        elif (mod % 3 == 1) "Woke"
        else "Dumb"
    );
print("Hello World");
let a = 10 in while (a >= 0) {
    print(a);
    a := a - 1;
}
gcd(a, b) => while (a > 0)
    let m = a % b in {
        b := a;
        a := m;
    };
for (x in range(0, 10)) print(x);
let iterable = range(0, 10) in
    while (iterable.next())
        let x = iterable.current() in
            print(x);
type Point {
    x = 0;
    y = 0;

    getX() => self.x;
    getY() => self.y;

    setX(x) => self.x := x;
    setY(y) => self.y := y;
}
type A {
    // ...
    f() {
        self := new A(); // <-- Semantic error, `self` is not a valid assignment target
    }
}
let pt = new Point() in
    print("x: " @ pt.getX() @ "; y: " @ pt.getY());
type Point(x, y) {
    x = x;
    y = y;

    // ...
}
let pt = new Point(3,4) in
    print("x: " @ pt.getX() @ "; y: " @ pt.getY());
type PolarPoint inherits Point {
    rho() => sqrt(self.getX() ^ 2 + self.getY() ^ 2);
    // ...
}